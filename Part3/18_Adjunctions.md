## 18. Adjunctions

수학적으로 한가지 대상이 다른 대상과 같다는 것은 많은 의미로 이야기 할 수 있습니다. 이 중 동등(equality)는 가장 엄격한 경우 입니다. 이는 두 대상을 구분할 수 없다면 같을 수 있다 말하는 것과 같습니다. 이경우에는 한가지 대상을 가능한 모든 경우에 같은 다른 대상으로 교체할 수 있습니다. 예를들어 우리가 가환 다이어그램을 이야기할때 사상의 동등함을 논했던것을 알아차리셨습니까? 사상들은 집합 홈셋을 형성하고 집합의 원소를 동등의 대상으로 비교될 수 있기 때문입니다.

하지만 동등은 때로는 너무 엄격합니다. 동등을 제외하고도 같음을 이야기 할 수 있는 의도나 목적은 매우 많이 들 수 있습니다. 예를 들어 (Boo, Char) 페어 타입을 봅시다 이는 엄밀히 말해 (Char, Bool) 타입과 같지 않습니다. 하지만 둘은 동일한 정보를 담고 있습니다. 이 개념은 두 타입간의 동형이라는 개념에 어울립니다. 동형사상(isomorphism)은 뒤집을 수 있는 사상입니다. 그리고 사상이기 때문에 이는 구조를 보존합니다. "iso"는 왕복과 동일한 의미입니다. 어떤 시작점에서 시작하더라도 다시 그 시작점으로 돌아올 수 있습니다. 페어의 경우 동형사상은 swap 이라는 함수처럼 나타낼 수 있습니다.

```haskell
swap :: (a, b) -> (b, a)
swap (a, b) = (b, a)
```

swap은 그 자체로 역이 존재합니다.



### 18.1 Adjunction and Unit/Counit Pair

카테고리가 동형임에 대하여 이야기할때 펑터라 불리는 이들간의 매핑으로 이야기 하였습니다. 두 카테고리 C, D가 있고 C에서 D로 가는 펑터 R(right)가 역이 존재할때 두 카테고리 C, D가 동형이라 말하고 싶습니다. 다시말해 D에서 C로 돌아가는 역방향의 펑터 L(left)가 존재하고 R과 함섭하였을때 이는 아이덴티티 펑터 I 일것입니다. 이경우 두가지 합성이 가능합니다: R . L, L . R

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-1.jpg?w=300&h=160)

그러면 두 펑터가 같다는 것은 무엇일까요? 이와같은 두 식이 같음은 무엇을 의미할까요?

>𝑅 ∘ 𝐿 = 𝐼𝐃, 𝐿 ∘ 𝑅 = 𝐼𝐂

펑터의 동등에 대하여 대상의 동등에 대해 정의하는것은 꽤 그럴듯 합니다. 동일 대상에 작동하는 펑터의 경우에는 동일한 결과물이 발생할 것 이기 때문입니다. 하지만 이는 일반적이지 않습니다. 특히나 임의의 카테고리의 원소에 대하여 동등을 비교하는 방법은 모릅니다.

펑터는 카테고리간의 사상으로 여길 수 있습니다. 이경우에 이들은 비교 가능해야합니다. 실제로 우리가 이야기하고 있는 스몰 카테고리에서는 사상이 집합을 이루고 집합의 원소에 대해서는 동등을 거론할 수 있기에 실제로 가능합니다.

카테고리의 카테고리 Cat이 실제 2-카테고리 인점을 주목하세요. 2-카테고리의 홈셋은 추가적인 구조가 있습니다. 1-사상에 대해 동작하는 2-사상이 있습니다. Cat에서 1-사상은 펑터이고 2-사상은 자연변환입니다. 그렇기에 펑터의 동등을 자연 동형(natural isomorphisms)으로 대신해서 생각하는 것은 매우 자연스럽습니다.

따라서 범주의 동형성 대신에 동등성에 대하여 더 일반적인 개념을 고려하는 것이 합리적 입니다. 카테고리 C, D 사이에 왔다갔다할 수 있는 펑터가 있을때 이 둘이 동등하다고 할 수 있습니다. 그리고 이들의 합성은 아이덴티티 펑터와 자연적으로 동형인 경우에 말입니다. 다시말해서 두가지 자연변환이 존재합니다: 𝑅 ∘ 𝐿와 𝐼𝐃(아이덴티티 D) 사이, 그리고 하나는 𝐿 ∘ 𝑅와  𝐼𝐂사이

수반(adjunction)은 동등성보다 더 약한 조건입니다. 두 펑터의 합성이 아이덴티티 펑터와 동형일 필요가 없기 때문입니다. 대신 이는 두가지 조건(자연변환)으로 분리되고 다음과 같이 나타낼 수 있습니다.

>𝜂∷𝐼𝐃 →𝑅∘𝐿 
>
>𝜀 ∷ 𝐿 ∘ 𝑅 → 𝐼𝐂

수반에서 𝜂는 unit, 𝜀는 counit 이라는 이름으로 불립니다.

두 정의간의 비대칭에 주목하세요. 일반적으로 나머지 두 매핑을 정의할 필요는 없습니다.

>𝑅 ∘ 𝐿 → 𝐼𝐃 not necessarily
>
>𝐼𝐂 → 𝐿 ∘ 𝑅 not necessarily

이 비대칭에 의해 L은 R의 left adjoint, R은 L의 right adjoint라 불립니다.

수반의 컴팩트한 스타일의 노테이션은 다음과 같습니다.

> 𝐿⊣𝑅

더 디테일하게 수반의 유닛과 코유닛을 알아보죠

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-unit.jpg?w=300&h=183)

유닛 먼저 시작해 봅시다. 이는 자연변환이기에 특정 사상들의 군 입니다. 카테고리 D의 한 대상 d가 있을때 이의 자연변환 𝜂의 컴포넌트는 id 간의 사상 입니다. 그리고 이는 d와 (R . L)d와 동등합니다. 위의 그림에서는 d'로 불립니다.

> 𝜂𝑑 ∷ 𝑑 → (𝑅 ∘ 𝐿)𝑑

 𝑅 ∘ 𝐿 합성이 카테고리 D의 엔도펑터임을 주목하세요.

위 방정식은 카테고리 D의 어떤 대상 d를 시작점으로 골라  𝑅 ∘ 𝐿을 이용하여 왕복을하면 타겟 대상 d'를 선택할 수 있음을 말합니다. 이후 타겟 오브젝트 까지의 화살표 - 𝜂𝑑 사상 - 을 그릴 수 있습니다.

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-counit1.jpg?w=300&h=181)

비슷하게 코유닛은 다음과 같이 나타낼 수 있습니다.

> 𝜀𝑐 ∷ (𝐿 ∘ 𝑅)𝑐 → 𝑐

이는 타겟으로 카테고리 C의 임의의 대상 c를 골라 𝐿 ∘ 𝑅로 왕복을 하면 나오는 소스오브젝트 c'는 𝑐′ = (𝐿 ∘ 𝑅)𝑐 입니다. 역시 그리고난 이후 소스에서 타겟까지 화살표 - 𝜀𝑐 사상 - 을 그릴 수 있습니다.

유닛과 코유닛을 보는 다른 방법은 다음과 같습니다. 유닛은 D에 아이덴티티 펑터를 삽입할 수 있는 곳 어디에서든 𝑅 ∘ 𝐿 합성을 야기(introduce)하고 코유닛은 합성 𝐿 ∘ 𝑅을 C의 아이덴티티 펑터로 대채하여 제거(eliminate) 할 수 있다는 점 입니다. 이는 연속된 야기와 제거가 아무것도 바꾸지 않는다는 명백한 일관성 조건으로 이어집니다.

>𝐿 = 𝐿 ∘ 𝐼𝐃 -> 𝐿 ∘ 𝑅 ∘ 𝐿 -> 𝐼𝐂 ∘ 𝐿
>
>𝑅 = 𝐼𝐃 ∘ 𝑅 -> 𝑅 ∘ 𝐿 ∘ 𝑅 -> 𝑅 ∘ 𝐼𝐂 = 𝑅

이것들은 triangular identities라 불립니다. 다음과같은 가환 다이어그램을 만들기 때문이죠

![](https://bartoszmilewski.files.wordpress.com/2017/02/triangles.png?w=209&h=151)![](https://bartoszmilewski.files.wordpress.com/2017/02/triangles-2.png?w=211&h=138)

이들은 펑터 카테고리에서의 다이어 그램 입니다: 화살표는 자연변환이고 그들의 합성은 자연변환의 수평적 합성입니다. 이 아이덴티티의 컴포넌트는 다음과 같습니다.

>𝜀𝐿𝑑 ∘ 𝐿𝜂𝑑 = id𝐿𝑑 
>
>𝑅𝜀𝑐 ∘ 𝜂𝑅𝑐 = id𝑅𝑐

하스켈에서 유닛과 코유닛은 종종 다른 이름으로 볼 수 있습니다. 유닛은 return으로 알려져있습니다.(또는 Applicative의 정의해서 pure)

```haskell
return :: d -> m d
```

그리고 코유닛은 extract로 알려져있습니다.

```haskell
extract :: w c -> c
```

여기서 m은 𝑅 ∘ 𝐿에 해당하는 (엔도)펑터 이고 w는 𝐿 ∘ 𝑅에 해당하는 (엔도)펑터 입니다. 조만간 보게 되겠지만 이들은 각각 모나드와 코모나드의 정의 중 일부 입니다.

엔도 펑터를 컨테이너로 생각할 수 있습니다. 이경우 유닛(or 리턴)은 임의의 타입을 감싸는 디폴트 박스를 만들어내는 다형성 함수로 볼 수 있고 코유닛은 이와 반대로 컨테이너로부터 값을 읽어들이거나 만들어내는 역할을 한다고 볼 수 있습니다.

조만간 모든 수반함자 쌍은 모나드와 코모나드를 정의하는것을 볼것입니다. 역으로 모든 모나드 혹은 코모나드는 수반함자의 쌍으로 분해될 수 있습니다. - 이 분해는 유니크 하지는 않습니다. 

하스켈에서 모나드를 많이 사용합니다. 하지만 수반함자의 쌍으로 분해하는 경우는 드믑니다. 그본적으로 이 펑터들은 Hask의 범위를 벗어나기 때문입니다.

하지만 엔도펑터의 수반은 하스켈에서 정의할 수 있습니다. 아래는 Data.Functor.Adjunction의 정의 일부분입니다.

```haskell
class (Functor f, Representable u) => Adjunction f u | f -> u, u -> f	where 
	unit :: a -> u (f a)
	counit :: f (u a) -> a
```

위 정의에는 설명이 필요합니다. 우선 이는 복수의 파라미터 타입 클래스 입니다 - f, u에 대한 두 파라미터. 이는 두 타입 생성자 사이에 Adjunction이라 불리는 관계를 형성합니다.

추가적으로 수직 바 | 이후에 함수적인 디펜던시를 구체화합니다. 예를들어 f -> u는 u는 f에 의해 결정됨을 의미합니다(f와 u사이의 관계는 함수이고 여기서 타입 생성자 입니다.) 반대로 u -> f는 u를 안다면 f가 유일하게 결정됨을 뜻합니다.

왜 하스켈에서 오른편 수반함자 u가 representable 인지는 나중에 설명하겠습니다.



### 18.2 Adjunctions and Hom-Sets

홈셋의 자연동형에 관하여 수반의 정의와 동등함이 있습니다. 이 정의는 지금까지 우리가 공부해온 universal construction과 매우 밀접합니다. 만일 어떤 구조를 분해시키는 유일한 사상이 있다는 말을 듣는다면 특정 집합을 홈셋으로 매핑하는 것을 생각해야합니다. 이는 유니크한 사상을 선택함을 뜻합니다.

더웃이 분해(factorization)는 자연변환으로 종종 묘사될 수 있습니다. 분해는 가환 다이어그램을 포함하고 - 어떤 사상은 두 사상의 합성(요인)과 동일합니다. 자연변환은 사상을 가환 다이어그램으로 매핑합니다. 따라서 universal construction에서 사상에서 가환 다이어그램으로 그리고 유일한 사상으로 이동합니다. 사상에서 사상으로 매핑이나 홈셋에서 다른 홈셋으로(대게 다른 카테고리의) 매핑하는것에 도착합니다. 만일 매핑이 뒤집을 수 있다면 그리고 자연스럽게 모든 홈셋으로 확장할 수 있다면 수반을 얻게 됩니다.

Universal construction과 수반의 주된 차이는 전역적이냐는 단어 입니다 - 모든 홈셋에 대하여. 예를들어 카테고리에서 모든 대상의 쌍을 정의할 수는 없어도 선택된 두 대상의 곱을 정의할 수 있습니다. 곧 보게 되겠지만 카테고리에 존재하는 모든 쌍의 곱을 정의할 수 있다면 이는 수반을 통하여 정의될 수 있습니다.

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-homsets.jpg?w=300&h=206)

여기 홈셋을 이용한 수반의 다른 정의가 있습니다. 이전에 두개의 펑터 L :: D -> C, R :: C -> D가 있었습니다. 그리고 임의로 카테고리 D에서 시작점으로 d, 카테고리 C에서 끝점으로 c를 선택했었습니다. d는 L로 매핑할 수 있고 이후 카테고리 C에는 두개의 대상 c, Ld가 생겼습니다. 이들은 홈셋을 형성합니다.

> C(Ld, c)

비슷하게 끝점 c를 R을 이용하여 매핑할 수 있고 이후 카테고리 D에서 두개의 대상 d와 Rc를 얻습니다. 마찬가지로 이들은 홈셋을 형성합니다.

>D(d, Rc)

이 홈셋이 동형이라면 L은 R의 left adjoint라 할 수 있습니다.

> C(Ld, c) ≅ D(d, Rc)

이는 d와 c 모두에 대한 자연변환입니다. Naturality은 소스 d가 D안에서 가변적일때 자연스럽게 c도 C 안에서 가변함을 뜻합니다. 더 정확하게 C에서 Set으로 향하는 두개의 (공변) 자연변환 𝜑 가 있습니다.

> c -> C(Ld, c)
>
> c -> D(d, Rc)

다른 자연변환 𝜓는 다음과 같은 (반변) 펑터 입니다.

> d -> C(Ld, c)
>
> d -> D(d, Rc)

 이 두 자연변환들은 뒤집을 수 있어야 합니다.

두 수반 정의가 동등하다는것을 보이는 것은 쉽습니다. 예를 들어 홈셋의 동형에서 시작하여 유닛 변환을 유도하는 것을 먼저 해 보겠습니다.

> 𝐂(𝐿𝑑, 𝑐) ≅ 𝐃(𝑑, 𝑅𝑐)

동형은 모든 대상 c에 대하여 작동해야 하기 때문에 c = Ld인 경우에도 만족해야 합니다.

> 𝐂(𝐿𝑑, 𝐿𝑑) ≅ 𝐃(𝑑, (𝑅 ∘ 𝐿)𝑑)

여기서 좌변을 만족하는 경우는 단위사상 하나가 임이 자명합니다. 자연변환은 이 사상을 𝐃(𝑑, (𝑅 ∘ 𝐿)𝑑)의 원소로 매핑하거나 혹은 다음과같이 아이덴티티 펑터 I가 추가된 사상과 같습니다.(The natural transformation will map this morphism to an element of 𝐃(𝑑 , (𝑅 ∘ 𝐿)𝑑 ) or, inserting the identity functor 𝐼 , a morphism in:)

> 𝐃(𝐼 𝑑 , (𝑅 ∘ 𝐿)𝑑 )

이제 d가 매게변수인 사상들을 얻을 수 있습니다. 이들은 펑터 I와 (𝑅 ∘ 𝐿) 사이에서 자연변환을 이룹니다. 이는 앞서 말한 유닛 𝜂와 일치합니다.

역으로 존재하는 유닛과 코유닛에서 시작하여 홈셋간의 변환을 정의할 수 있습니다. 예를들어 홈셋 C(Ld, c)에서 임의의 사상 f를 선택해 봅시다. f에 대해 동작하는  𝜑를 원합니다. 그리고 이는 D(d, Rc)의 사상입니다.

선택권이 거의 없습니다. 우리가 할 수 있는것은 f를 R로 리프팅하는 것 입니다. 이는 R(Ld) -> Rc에 해당하는 Rf를 만들어 냅니다. 그리고 이는 𝐃((𝑅 ∘ 𝐿)𝑑, 𝑅𝑐)의 원소입니다.

𝜑의 컴포넌트로 필요한것은 d에서 Rc로 향하는 사상입니다. 𝜂𝑑를 이용할 수 있기에 (d -> (𝑅 ∘ 𝐿)𝑑) 이를 쉽게 얻을 수 있습니다.

> 𝜑𝑓 = 𝑅𝑓 ∘ 𝜂𝑑

다른 방향도 유사하며 𝜑의 파생도 마찬가지 입니다.

하스켈의 Adjunction 정의로 돌아와 자연변환 𝜑, 𝜓는 leftAdjunct, rightAdjunct라는 다형성(a, b에 대한)로 나타낼 수 있습니다.

```haskell
class (Functor f, Representable u) =>
	Adjunction f u | f -> u, u -> f where
		leftAdjunct :: (f a -> b) -> (a -> u b)
		rightAdjunct :: (a -> u b) -> (f a -> b)
```

unit/counit 공식과 leftAdjunct/rightAdjunct 공식 사이의 동등성은 다음 매핑으로 증명됩니다.

```haskell
unit 						= leftAdjunct id
counit					= rightAdjunct id
leftAdjunct f		= fmap f . unit
rightAdjunct f	= counit . fmap f
```

수반을 카테고리적으로 묘사하는 것을 하스켈 코드로 옮기는 것은 매우 도움이 됩니다. 직접 해보는것을 매우 추천합니다.

이제 왜 하스켈에서 right adjoint가 자동으로 representable functor가 되는지 설명할 차례입니다. 이는 하스켈의 타입들을 집합들의 카테고리로 간주할 수 있다는 점에서 첫번째 시작합니다.

만일 오른쪽 카테고리 D가 Set일때 R은 C -> Set인 펑터 입니다. 이런 펑터는 C에서 rep 대상을 찾을 수 있다면 홈펑터 C(rep, -)가 자연스럽게 R과 동형이 되도록 표현할 수 있습니다. R이  C -> Set인 어떤 펑터 L의 right adjoint 이면 그러한 대상이 언제나 존재합니다. - 이는 L안에 있는 싱글톤셋의 이미지 입니다.

> rep = L( )

실제로 수반은 다음 두 홈셋이 자연적으로 동형임을 보입니다.

> 𝐂(𝐿(), 𝑐) ≅ 𝐒𝐞𝐭((), 𝑅𝑐)

주어진 모든 c에 대하여 우변은 싱글톤 셋 ( )에서 Rc로 향하는 함수들의 집합 입니다. 이는 이미 R c 집합에서 원소를 골라내는것임을 보았었습니다. 이와같은 함수들의 집합은 Rc 집합과 동형이기에 다음을 얻을 수 있습니다.

> 𝐂(𝐿(), −) ≅ 𝑅

이는 R이 참으로 representable 하다는 것을 보입니다.



### 18.3 Product from Adjunction

일전에 universal construction을 이용하는 몇가지 컨셉을 소개했었습니다. 이 컨셉들은 전역적으로 정의될때 수반을 이용하여 표현한는것이 더 쉽습니다. 가장 단순한 예는 product 입니다. 곱의 universal construction의 요점은 어떤 product 후보자들도 universal product로 분해될 수 있음을 뜻합니다

더 정확하게는 두 대상 a, b의 곱은 대상 (a x b) 이고(하스켈 에서는 (a, b)) 이들은 두개의 사상 fst, snd가 있습니다. 어떤 후보자 c와 다음과 같은 사상 p :: c -> a, q :: c -> b가 있을때 p와 q를 각각 fst, snd를 통하여 분해할 수 있는 유일한 사상 m :: c -> (a, b)가 존재합니다.

하스켈에서 일전에 보았듯이 factorizer를 두개의 투영에서 이 사상을 만들어 내는 것으로 구현할 수 있습니다.

```haskell
factorizer :: (c -> a) -> (c -> b) -> (c -> (a, b))
factorizer p q = \x -> (p x, q x)
```

분해의 조건이 다음과 같다는것을 보이는 것은 쉽습니다.

```haskell
fst . factorizer p q = p
snd . factorizer p q = q
```

여기서 두개의 사상 쌍 p, q를 입력받아 다른 사상 m = factorizer p  q 를 만들어 낼 수 있습니다.

수반을 정의하기 위하여 이것을 홈셋 간의 매핑으로 해석할 수 있을까요? 이는 Hask의 범위를 넘어 두개의 사상 쌍을 곱 카테고리에서의 하나의 사상으로 다루는 것을 통해 보일 수 있습니다.

곱 카테고리에 대해 상기해보죠. 이는 두개의 임의의 카테고리 C, D가 필요합니다. 곱 카테고리에서 대상은 C x D이고 이는 C에서 온 대상과 D에서 온 대상의 쌍입니다. 마찬가지로 사상은 각각의 카테고리에서 온 사상의 쌍 입니다.

어떤 카테고리 C의 product를 정의하기 위하여 C x C 곱 카테고리 부터 시작 하여야 합니다. C에서 나온 사상 쌍은 C x C 곱 카테고리에서 하나의 사상입니다.

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-productcat.jpg?w=300&h=223)

처음에 약간 혼란스러울 수 있습니다. 곱을 정의하기 위하여 곱 카테고리를 이용하고 있기 때문입니다. 이것들은 하지만 매우 다른 곱 입니다. 곱 카테고리에서는 universal construction이 필요하지 않습니다. 우리가 필요한것은 대상의 쌍과 사상의 쌍 이라는 개념뿐 입니다.

하지만 C의 대상들의 쌍은 C에 속하지 않습니다. 이는 C x C 카테고리의 대상입니다. 이를 공식적으로 <a, b>로 쓸 수 있습니다. 그리고 여기서 a, b는 C의 대상입니다. 반대로 같은 C 카테고리에 속하는 a x b를 정의하기 위하여 universal construction은 필요합니다. universal construction에 의해 구체화되는 이 대상은 쌍 <a, b>로 표현될것임이 추정됩니다. 이는 항상 존재하지 않기도 하고 존재 하더라도 C에 속한 모든 대상의 쌍에 대해 존재하지 않을 수 있습니다.

이제 factorizer를 홈셋의 매핑으로 다시 봅시다. 첫번쨰 홈셋은 곱 카테고리 C x C에 속합니다. 그리고 두번째 홈셋은 C에 속합니다. C x C의 일반적인 사상은 사상의 쌍 <f, g> 입니다.

> 𝑓 ∷ 𝑐′ → 𝑎
>
> 𝑔 ∷ 𝑐′′ → 𝑏

𝑐′′는 잠정적으로 𝑐′와 다를 수 있습니다. 하지만 곱을 정의하기 위해 우리는 c를 공유하는 특별한 사상 p, q 쌍에 관심이 있습니다. 수반에서 좌측 홈셋의 소스는 임의의 대상이 아닙니다 - 이는 우측 카테고리의 어떤 대상에 작동하는 레프트 펑터 L의 결과물 입니다. 이를 만족하는 펑터를 추측하는 것은 쉽습니다. - 이는 C -> C x C로 향하는  Δ 펑터 입니다. 이 펑터는 대상에 대하여 다음과 같이 동작합니다.

> Δ 𝑐 = ⟨𝑐, 𝑐⟩

이렇기에 좌변의 홈셋은 다음과 같습니다.

> (𝐂 × 𝐂)(Δ 𝑐, ⟨𝑎, 𝑏⟩))

이는 곱 카테고리에서 홈셋 입니다. 이의 원소는 사상 쌍이고 factorizer의 아규먼트에 해당한다고 알아차릴 수 있습니다.

```haskell
(c -> a) -> (c -> b) ...
```

우변의 홈셋은 카테고리 C에 속합니다. 그리고 이는 소스 오브젝트 c와 C x C의 타겟 오브젝트에 대해 동작하는 R 펑터의 결과물 사이에 동작합니다. 이는 <a, b> 쌍을 a x b로 매핑하는 펑터입니다. 이제 우변에 해당하는 홈셋의 원소는 factorizer의 결과와 같다는것을 알 수 있습니다.

```haskell
... -> (c -> (a, b))
```

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-product.jpg?w=300&h=194)

아직 수반을 완전히 정의할 수 없습니다. factorizer는 역이 존재해야합니다. - 우리는 홈셋간의 동형을 보이고 있습니다. factorizer의 역은 사상 m에서 부터 시작해야 합니다. m은 C(a, a x b)의 원소입니다.

factorizer의 역은 m을 C x C에 속한 <p, q> 사상으로 매핑해야 합니다.(<c, c> -> <a, b>) 그리고 이는 다음 홈셋의 원소입니다.

> (𝐂 × 𝐂)(Δ 𝑐, ⟨𝑎, 𝑏⟩)

해당 매핑이 존재한다면 대각선 펑터의 우측 인접이 존재한다고 결론을 내릴 수 있습니다. 이 펑터는 곱을 정의합니다.

하스켈에서 factorizer의 역을 정의하는것은 m을 각각 fst, snd와 합성해서 쉽게 구할 수 있습니다.

```haskell
p = fst . m
q = snd . m
```

곱을 정의하는 두가지 방법들의 동등을 증명을 완성하기 위하여 홈셋간의 매핑이 a, b, c에 대하여 자연적임을 보여야 합니다. 이는 숙제

요약해 봅시자. 카테고리적 곱은 범용적으로 대각선 펑터의 우측 인접으로 정의될 수 있습니다.

> (𝐂 × 𝐂)(Δ 𝑐,⟨𝑎,𝑏⟩) ≅ 𝐂(𝑐,𝑎 × 𝑏)

여기서 a x b는 우측인접펑터 Product가 <a, b> 쌍에 대해 작동한 결과입니다. C x C에서 나오는 펑터는 바이펑터(bifunctor) 임을 주목하세요. Product도 바이펑터입니다. 하스켈에서 Product 바이펑터는 단순하게 ( , ) 로 쓰입니다. 두개의 타입을 다음과같이 적용하여 곱 타입을 얻을 수 있습니다.

```haskell
(,) Bool Int = (Bool, Int)
```



### 18.4 Exponential from Adjunction

b^a 익스포넨셜, 혹은 함수 객체 a => b는 universal construction으로 정의될 수 있습니다. 이 구조는 모든 대상의 쌍이 존재하면 수반으로 볼 수 있습니다. 

> 다른 대상 z와 사상 g :: z x a -> b에 대하여 다음과 같은 유일한 사상이 존재합니다. h :: z -> (a => b)

이 말은 홈셋간의 매핑을 형성합니다.

이 경우에 우리는 같은 카테고리에 속하는 대상을 다룹니다. 그렇기에 두 수반 펑터는 엔도펑터 입니다. 레프트펑터 L은 z를 z x a로 만듭니다. 이는 a가 고정된 경우에 곱을 만드는 것과 같습니다.

라이트 펑터 R은 b에 동작할때 a => b를 만듭니다. 역시 이경우 a가 고정입니다. 이 두 펑터간의 수반은 종종 다음과 같이 표현됩니다.

> −×𝑎 ⊣ (−)𝑎

이 수반에 내재된 홈셋의 매핑을 보이기 위하여 universal construction을 보일때 이용한 다이어그램을 그려보는것은 유용합니다.

![](https://bartoszmilewski.files.wordpress.com/2016/04/adj-expo.jpg?w=300&h=180)

여기서 eval 사상은 단지 이 수반의 코유닛 임을 주목하세요

```haskell
(a => b) x a -> b
(a => b) x a = (L . R)b
```

이전에 universal construction이 동형에 따라 고유한 대상을 정의한다고 언급했었습니다. That’s why we have “the” product and “the” exponential. 이 속성은 수반으로도 변환됩니다. 펑터가 adjoint가 있는경우 이는 동형에 따라 유일합니다.



