## 19. Free/Forgetful Adjunctions



Free Construction은 매우 강력한 adjunction의 응용 입니다. free functor는 forgetful functor의 좌측 수반 입니다. 반대로 forgetful 펑터는 대게 특정 구조를 잃는 매우 단순한 펑터 입니다. 예를들어 많은 카테고리들이 집합에서부터 만들어질 수 있습니다. 하지만 이 집합을 추상화한 카테고리의 대상은 내부의 구조가 없습니다. - 카테고리의 대상이 된 집합은 더이상 원소를 까볼 수 없습니다. 반면 이 대상들은 종종 집합의 기억을 운반합니다. 어떠한 펑터가 대상이 속한 카테고리 C에서 Set으로 매핑한다면 말입니다. C의 대상과 매칭되는 이 집합은 내재된 집합(underlying set)이라 불립니다.

Monoid도 내제된 집합을 지니는 대상입니다. forgetful 펑터는 모노이드의 카테고리 Mon에 있는 모노이드 대상을 이들의 내재된 집합으로 매핑합니다. 이는 물론 모노이드 사상(준동형 사상 - homomorphisms)을 집합간의 함수로 매핑합니다.

Mon의 성격을 두개로 분리해서 봅시다. 하나는 이를 증식?(multiplication)된 집합과 유닛 엘리먼트의 다발 이라 볼 수 있는 점이고 다른 하나는 특징이 없는 대상과 그들간의 사상만이 유일한 구조인 카테고리로 볼 수 있다는 점 입니다. 증식(multiplication)과 유닛을 만족시키는 모든 함수 집합은 Mon에서 사상으로 나타납니다.

아래의 사항을 기억하세요.

- 동일한 집합으로 매핑될 수 있는 모노이드들이 존재합니다.
- 모노이드간 사상 모노이드에 내제된 집합간 이루는 함수보다 적어야 합니다.

forgetful functor의 왼쪽 수반인 펑터 F는 free 펑터 입고 이들의 생성자 집합을 이용하여 free 모노이드를 만들어 냅니다. 수반은 이전에 이야기 나누었던 자유 모노이드의 universal construction에 의해 유래됩니다.

![](https://bartoszmilewski.files.wordpress.com/2016/05/forgetful.jpg?w=377&h=234)

홈셋과 관련해서 수반을 다음과 같이 쓸 수 있습니다.

> 𝐌𝐨𝐧(𝐹𝑥,𝑚) ≅ 𝐒𝐞𝐭(𝑥,𝑈𝑚)

이 동형이(x와 m에 대하여 자연적임) 보이는 바는 다음과 같습니다.

- x에서 만들어진 자유 모노이드 Fx와 임의의 모노이드 m간의 모든 homomorphism에 대하여 생성자 x를 m의 내재된 집합으로 임베딩 시키는 유일한 함수가 있습니다. 이 함수는 Set(x, Um)에 속합니다.
- x를 m의 내재된 함수로 임베딩 시키는 모든 함수에 대하여 x에 의해 생성된 자유 모노이드에서 m으로 향하는 유일한 사상이존재합니다.(이 사상은 universal construction에서 h라 불렀습니다.)

![](https://bartoszmilewski.files.wordpress.com/2016/05/freemonadjunction.jpg?w=512&h=203)

여기서 얻을 수 있는 직관은 Fx는 x를 기반으로 하여 얻을 수 있는 최대의 모노이드 라는 점 입니다. 우리가 모노이드들의 내부를 들여다 볼 수 있다면 Mon(Fx, m)에 속한 사상들이 이 자유 모노이드를 m으로 임베딩 시킴을 볼 수 있을것입니다. 이는 일부 원소를 식별해야 가능합니다. 특히 이는 Fx의 생성자(x의 원소)를 m으로 임베딩 시킵니다. 수반은 우측의 Set(x, Um)에서 제공된 함수에 의하여 x의 고유한 임베딩이 결정됨을 보이고 반대의 경우도 마찬가지 입니다.

하스켈에서 리스트 데이터 구조는 자유 모노이드 입니다. 리스트 타입 [a]는 생성자들의 집합을 나타내는 자유 모노이드 입니다. 예를들어 [Char] 리스트는 유닛 엘리먼트로 엠티 리스트 [ ]를 포함하고 싱글톤 리스트 ['a'], ['b']와 같은 자유 모노이드의 생성자를 포함합니다. 나머지들은 이 두 값을 곱(product)하여 얻어집니다. 여기서 두개의 리스트는 단순하게 하나를 다른 하나에 어펜딩 시킬 수 있습니다. 어펜딩은 교환법칙을 만족하고 유닛객체도 있습니다(엠티리스트). Char로 만들어진 자유 모노이드는 단지 Char에 속한 모든 문자열들의 집합입니다. 하스켈에서는 이를 String이라 부릅니다.

```haskell
type String = [Char]
```

다른 흥미로운 예는 하나의 생성자로만 만들어지는 자유 모노이드 입니다. [( )] 이들의 원소는 [ ], [( )], [( ), ( )],,, 와 같습니다. 이와 같은 모든 리스트들을 길이라는 자연수로 묘사될 수 있습니다. 길이 외에 유닛들의 리스트에서 얻을 수 있는 정보는 없습니다. 이 리스트들간 어펜딩하여 만들어진 새로운 리스트의 길이는 모든 구성요소들의 길이 합과 같습니다. [( )] 타입이 자연수(0과 함께)의 additive monoid와 동형이라는 것을 보이는것은 쉽습니다. 이 동형을 보이는 서로 역의 관계인 두 함수는 아래와 같습니다.

```haskell
toNat :: [()] -> Int
toNat = length
toList :: Int -> [()]
toList n = replicate n ()
```

 

### 19.1 Some Intuitions

free/forgetful adjunctions에서 통찰을 얻기 위하여 펑터와 함수는 자연적으로 손실이 발생한다는 점을 유의하면 좋습니다. 펑터는 여러 대상이나 사상을 뭉갤 수 있고 함수는 집합의 원소들을 하나로 합칠수도 있습니다. 또한 그들의 상은 공역의 일부분 일 수 있습니다.

Set의 평균적인 홈셋은 손실이 적은 것부터 시작하여 전체 함수 스펙트럼을 포함하여 정의역을 하나의 원소로 뭉개버리는 constant functions에서 멈출것 입니다.

임의의 카테고리에서 손실이 있는 사상도 마찬가지로 생각해도 됩니다. 이는 단지 머리속의 모델이지만 수반을 생각할때 매우 유용합니다.  - 특히 한쪽 카테고리가 Set인 경우

정식적으로 역이 있거나 없는 사상만 이야기 할 수 있는데  손실이 발생하는 경우는 후자의 경우 입니다. 또한 injective(겹치는게 없음), subjective(공역을 모두 커버)를 일반화한 mono-, epi- 사상 개념이 있습니다. 동시에 mono, epi하지만 역이 없는 사상도 가능합니다.

Free ⊣ Forgetful adjunction에서 좌측의 카테고리 C가 우측의 D보다 더 제약이 많습니다. C에 속한 사상은 추가적인 구조를 보존해야 하기 때문에 더 적습니다. Mon의 경우 이들은 multiplication과 유닛을 만족하여야 합니다. 그리고 D에 속한 사상은 보존해야할 구조가 없기 때문에 더 많습니다.

C의 대상 c에 망각함자 U를 적용할때 이를 c의 내부 구조를 드러낸다 생각하여도 좋습니다. 사실 D가 Set이면 U는 c의 내재된 집합을 드러내는 것으로 생각할 수 있습니다.

만일 c', c를 U를 이용하여 매핑하는 경우 일반적으로 C(c', c)는 D(Uc', Uc)의 일부분만 커버한다고 예상합니다. 이는 C(c', c)가 추가적인 정보를 보존하여야하기 때문입니다.

![](https://bartoszmilewski.files.wordpress.com/2016/05/forgettingmorphisms.jpg?w=413&h=219)

하지만 수반은 특정 홈셋도 동형임을 정의하기 때문에 c'를 고르는것은 매우 까다로워 집니다. 수반에서 c'는 C에서 아무 원소나 고르는게 아니라 자유펑터 F의 상 입니다.

> 𝐂(𝐹𝑑,𝑐) ≅ 𝐃(𝑑,𝑈𝑐)

그러므로 F의 상은 c로 갈 수 있는 대상들로 구성되어야 합니다. 사실 Fd에서 c까지 구조를 보존하는 사상이 d에서 Uc까지 구조를 보존하는 사상만큼 많이 있어야 합니다. 이는 본질적으로 F의 상이 구조가 없는 대상으로 구성되어야 함을 의미합니다.(사상으로 보존되는 구조도 없음). 이와같은 "structure-free" 대상을 free objects라 부릅니다.

![](https://bartoszmilewski.files.wordpress.com/2016/05/freeimage.jpg?w=422&h=249)

모노이드를 예를 들어 자유 모노이드는 유닛과 결합법칙으로 만들어진것 외에 구조가 없습니다. 그 외에는 모든 곱이 새로운 요소를 생성합니다.

자유모노이드 2*3은 6이 아닙니다. - 이는 새 원소 [2, 3] 입니다. [2, 3]과 6을 구분할 방법이 없기 때문에 이 자유모노이드에서 다른 모노이드 m으로의 매핑은 각각 할 수 있습니다. m의 동일한 원소로 두개가 매핑되는것도 가능합니다. 혹은 [2, 3]과 additive monoid에서온 5(합)을 구분하거나. 다른종류의 식별로 다른 모노이드를 얻게됩니다.

이는 다른 흥미로운 통찰을 유도합니다. 자유 모노이드는 모노이드적 연산을 수행하기 이전에 입력받은 어규먼트를 축적합니다. 2와 3을 곱하기 전에 리스트에 2와 3을 기억하는 것과 마찬가지로 말입니다. 이 방법의 장점은 모노이드적 연산을 정의할 필요가 없기 때문에 유용합니다. 단지 입력받은것들을 축적하고 마지막에 연산 결과를 적용합니다. 자유 모노이드는 그것의 evaluation부터 expression의 생성을 분리합니다. algebras에서 이를 다시 볼것입니다.

이 통찰을 다른것으로 일반화 됩니다. 더 정교하게는 free constructions로 일반화 합니다. 예를들어 우리는 트리의 모든 expression을 evaluating 이전에 축적시킬 수 있습니다. 여기서 얻을 수 있는 장점을 트리의 evaluation을 더 빠르게 만들거나 메모리 소요가 더 적게 만들 수 있다는 점 입니다. 예를들어 행렬곱을 보죠, 하나하나 다 evaluation하면 중간 결과를 저장하기 위하여 임시 배열이 많이 할당되게 됩니다.















