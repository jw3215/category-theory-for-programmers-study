## 20. Monads: Programmer's Definition



 프로그래머들은 모나드에 대한 신화를 개발했습니다. 모나드는 프로그래밍에서 가장 추상적이고 어려운 개념중에 하나입니다. 누군가는 이해했고 다른 누군가는 그렇지 못합니다. 많은 사람들이 모나드의 개념을 이해하는 신비로운 순간을 경험합니다. 모나드는 우리가 일상 생활에서 그것에 대한 좋은 비유를 할 수 없을 정도로 다양한 구조의 본질을 추상화 합니다. 우리는 이 모나드에 대한 어둠속에서 더듬거리며 마치 맹인이 코끼리는 만지며 이것은 줄이야! 이것은 나무 줄기야! 이것은 부리또야! 라고 외치는 것과 같게 행동합니다.

모나드에 대한 모든 신비주의는 오해의 결과로 생긴것 입니다. 모나드는 매우 단순한 컨셉입니다. 모나드의 매우 다양한 응용으로 인해 혼란이 야기 됩니다.

모나드의 응용은 매우 다양하지만 그 본질은 매우 단순합니다. 이 본질은 여러개를 합치는 것 입니다. 더 정확하게는 모나드가 합성한다는 것 입니다.

이것은 많은 프로그래머, 특히 명령형 언어 배경에서 온 사람들이 모나드를 이해하는데 어려움을 겪는 것을 부분적으로 설명합니다. 문제는 우리는 포르그래밍을 함수의 합성으로 생각하지 않는다는 점 입니다. 이는 이해할 수 있습니다. 우리는 종종 어떤 값을 함수에서 함수로 곧바로 전달하기보다 중간에 변수를 지정하곤 합니다. 또한 코드의 짧은 세그먼트들을 헬퍼 펑션으로 추상화하지 않고 인라인하기도 합니다. 다음은 C로 작성된 명령형 언어에서 벡터의 길이를 구하는 코드입니다.

```c
double vlen(double * v) {
  double d = 0.0;
  int n;
  for (n = 0; n < 3; ++n) 
    	d += v[n] * v[n];
  return sqrt(d);
}
```

이를 명시적으로 함수합성으로 구현한 하스켈 버전과 비교해보세요

```haskell
vlen = sqrt . sum . fmap (flip (^) 2)
```

하스켈의 point-free 스타일이 항상 좋다고 주장하는 것은 아닙니다. 하지만 중요한점은 함수 합성이 우리가 작성하는 프로그래밍의 밑바닥을 구성한다는 점 입니다. 그리고 우리사 효과적으로 함수 합성을 구성하고 있음에도 불구하고 하스켈은 모나딕 구성을 위한 do 표기법 이라는 명령형 구문을 제공하기 위해 많은 노력을 기울이고 있습니다. 이를 나중에 볼텐데 우선은 왜 모나딕 합성이 필요한지 알아볼 것 입니다.



### 20.1 The Kleisli Category

일반 함수의 리턴값을 장식값으로 바꾸는 writer monad를 일전에 보았었습니다. 이 장식은 함수의 리턴값과 스트링, 더 일반적으로는 모나드의 엘리먼트를 페어로 만들면서 완성됩니다. 그리고 펑터를 배웠으니 이 장식이 펑터라는것은 이제 알 수 있습니다.

```haskell
newtype Writer w a = Writer (a, w)

instance Functor (Writer w) where
	fmap f (Writer (a, w)) = Writer (f a, w)
```

다음으로는 이 장식함수를 합성하는 법 혹은 Kleisli arrows를 배웠었습니다.

```haskell
a -> Writer w b
```

이제 우리는 클라이슬리 카테고리를 더 일반적인 의미로 정의할 준비가 되었습니다. 어떤 카테고리 C와 엔도펑터 m로 시작해 봅시다 C에 대응되는 클라이슬리 카테고리 K는 C와 동일한 대상을 지닙니다. 하지만 사상은 다릅니다. a와 b간의 사상은 K에서 다음과 같습니다.

```haskell
a -> m b
```

K의 클라이슬리 화살표를 a와 m b 간의 사상이 아니라 a와 b 간의 사상으로 취급한다는것을 명심하세요.

위의 예에서 m은 고정된 모노이드 w에 대해 Writer w로 구현되었습니다.

클라이슬리 화살표가 합성할 수 있다면 카테고리를 형성합니다. 그리고 합성이 결합법칙을 만족하고 모든 대상에 대하여 항등 사상이 존재한다면 펑터 m은 모나드라 불리고 이 카테고리는 클라이슬리 카테고리라 불립니다.

하스켈에서 클라이슬리 합성은 피쉬 오퍼레이터 >=> 로 정의되고 이의 단위 화살표는 return이라 불리는 다형성 함수로 정의됩니다.

```haskell
class Monad m where
	(>=>) :: (a -> m b) -> (b -> m c) -> (a -> m c)
	return :: a -> m a
```

모나드를 정의하는 방식이 많고 위는 하스켈 에코시스템에서 주된 방식이 아니라는 점에 주목하세요. 나는 이 방식의 개념적 단순함과 이것으로 얻을 수 있는 직관으로 인해 좋아합니다. 하지만 프로그래밍에 편리한 방식들이 더 있습니다. 나중에 이를 잠깐 이야기할것 입니다.

이 공식에서 모나드의 법칙은 매우 쉽게 표현됩니다. 하스켈에서 이를 강제할수는 없지만 방정식 추론에 사용할 수 있습니다. 이는 클라이슬리 카테고리의 표준 구성 방식입니다.(They can not be enforced in Haskell, but they can be used for equational reasoning. They are simply the standard composition laws for the Kleisli category:)

```haskell
(f >=> g) >=> h = f >=> (g >=> h) -- associativity
return >=> f = f	-- left unit
f >=> return = f  -- right unit 
```

위 정의는 모나드가 무엇인지를 표현합니다: 이는 장식 함수를 합성하는 것 입니다. 이는 사이드 이펙트나 상태에 대한 것이 아닙니다. **합성에 관한것 입니다.**  나중에 보게되겠지만 장식함수는 사이드 이펙트나 상태를 표현할 수 있습니다. 하지만 이들은 모나드의 본질이 아닙니다. 모나드는 장식된 함수의 한쪽 끝을 다른 장식된 함수와 연결하는 끈적끈적한 덕테이프(duct tape)와 같습니다.

Writer 예제로 돌아가서, Writer는 모나드 이기 때문에 로깅함수(Writer 펑터의 클라이슬리 화살표)는 카테고리를 형성합니다.

```haskell
instance Monoid w => Monad (Writer w) where
	f >=> g = \a ->
		let Writer (b, s) = f a
				Writer (c, s') = g b
    in Writer (c, s 'mappend' s')
  return a = Writer(a, mempty)
```

Writer w에 대한 모나드 법칙은 w를 위한 모나드 법칙이 성립하는 이상 만족합니다.(하스켈에서 이를 강제할 수 없습니다.)

tell이라는 Writer 모나드에 대하 정의된 유용한 클라이슬리 화살표가 있습니다. 이 함수의 목적은 인수에 어규먼트를 추가하는 것 입니다.

```haskell
tell :: w -> Writer w ()
tell a = Writer((), s)
```

이를 나중에 모나딕 함수 블럭을 만드는데 사용할 것 입니다.



### 20.2 Fish Anatomy

다양한 종류의 모나드에 대해서 피쉬 오퍼레이터를 구현한다면 금새 이 코드들에 중복이 많고 공통 요소들로 분해할 수 있음을 알아차릴 것 입니다. 시작에 앞서 두 함수의 클라이슬리 합성은 함수를 리턴해야 합니다. 그렇기에 이 구현은 어규먼트 a로 시작하는 람다가 될 것 입니다.

```haskell
(>=>) :: (a -> m b) -> (b -> mc) -> (a -> mc)
f >=> g = \a -> ...
```

여기서 우리가 유일하게 할 수 있는것은 단지 f를 넘기는 것 입니다.

```haskell
f >=> g = \a -> let mb = f a
								in ...
```

이제는 m c 타입의 결과물을 만들어 내야 합니다. 그리고 위의 제안에서 m b 타입과 함수 g :: b -> m c 가 있습니다. 이를 위한 함수를 정의해 봅시다. 이 함수를 bind라 불리고 다음과 같이 중위연산자로 쓰입니다.

```haskell
(>>=) :: m a -> (a -> m b) -> m b
```

이러면 모든 모나드에 대해서 피쉬 오퍼레이터말고 바인드 오퍼레이터를 정의할 수 있습니다. 사실 하스켈에서 모나드의 정의는 바인드를 이용합니다.

```haskell
class Monad m where
	(>>=) :: m a -> (a -> m b) -> m b
	return :: a -> m a
```

다음은 Writer 모나드를 위한 바인드의 정의 입니다.

```haskell
(Writer (a, w)) >>= f = let Writer (b, w') = f a
												in Writer (b, w 'mappend' w')
```

이는 실제로 피쉬오퍼레이터의 정의보다 짧습니다.

m이 펑터라는 사실을 이용하여 바인딩을 추가로 분석할 수 있습니다.  fmap을 이용하여 a -> m b 함수를 m a의 내용물에 적용할 수 있습니다. 이는 a를 m b로 바꿀것이고 결과는 m (m b) 타입일것 입니다. 이는 우리가 정확이 원하는 타입 m b가 아닙니다. 이제 필요한것은 두번 적용된 m을 평평하게 합쳐버리는 것 입니다. 이와같은 함수는 join이라 불립니다.

```haskell
join :: m (m a) -> m a 
```

join을 이용하여 bind를 다음과 같이 다시 쓸 수 있습니다.

```haskell
ma >>= f = join (fmap f ma)
```

여기서 명시적으로 m이 펑터이기를 요청했고 위에서 본 모나드에 대한 두가징 정의가 필요없어 졌습니다. 이는 fish혹은 bind 연산자를 지원하는 모든 타입 생성자 m이 자동으로 펑터이기 때문입니다. 예를들어 bind와 return에 대하여 fmap을 다음과 같이 정의할 수 있습니다.

```haskell
fmap f ma =ma >>= \a -> return (f a)

-- join for Writer Monad
join :: Monoid w => Writer w (Writer w a) -> Writer w a
join (Writer (Writer (a, w'), w)) = Writer (a, w 'mappend' w')
```



### 20.3 The do Notation

모나드를 이용해 코드를 짜는 한 방식은 클라이슬리 화살표(피쉬 오퍼레이터)를 이용하여 합성하는 것 입니다. 이 방식의 프로그래밍은 point-free 스타일의 일반화 버전 입니다. Point-free 코드는 더 컴팩트하고 종종 더 우아합니다. 하지만 일반적으로 이들은 이해하기 힘들고 코드의 난해함을 증가시킵니다. 이는 대부분의 프로그래머들이 함수 아규먼트나 매게변수들에 이름을 부여야하는 이유입니다.

모나드를 다루는것은 피쉬 오퍼레이터보다는 바인드 연산자를 이용하는것을 선호함을 뜻합니다. 바인드 오퍼레이터는 모나딕 발류를 받아 모나딕 발류를 리턴합니다. 프로그래머들은 이 값에 이름을 부여하는것을 결정할 수 있습니다. 그러나 이는 거의 개선되지 않았습니다. 우리가 정말로 원하는것은 값을 캡슐화한 모나드가 아니라 캡슐된 값을 다루는것 처럼 하는것 입니다. 이는 명령형 코드가 하는 방식입니다. - 글로벌 로그를 남기는 사이드 이펙트는 숨겨져야 합니다. 이것이 바로 하스켈에서 do 표기법이 모방하는 것 입니다.

그럼 이제 왜 모나드를 사용하는지에 의문이 들것입니다. 사이드이펙트를 보이지 않기 원한다면 왜 명령형 언어를 고수하지 않는 이유는 무엇입니다까? 정답은 모나드는 사이드 이펙트를 컨트롤할 수 있는 더 좋은 방식이기 때문입니다. 예를들어 Writer 모나드의 로그는 함수간에 전달되고 이과정에 전역적으로 노출되지 않습니다. 이과정에 로그가 오염되거나 레이스 컨디션의 대상이 될 일은 없습니다. 또한 모나딕한 코드는 더 명확하게 나머지 프로그램의 부분과 구분됩니다.

do 표기법은 단지 모나딕 합성에 syntactic sugar 입니다. 표면적으로 이는 명령형 코드와 비슷합니다. 하지만 이는 일련의 바인딩 및 람다식으로 직접 변환됩니다.

예를들어 Writer 모나드의 클라이슬리 화상표의 합성을 예를 들어 봅시다. 

```haskell
process :: String -> Writer String [String]
process = upCase >=> toWords
```

process 함수는 입력받은 문자열의 캐릭터들을 대문자로 바꾸고 단어로 나눕니다. 이 과정중에 동작으로 로그로 기록합니다.

do 표기법을 이용하면 다음과 같이 나타낼 수 있습니다.

```haskell
process s = do 
	upStr <- upCase s
	toWords upStr
```

여기서 upCase는 Writer를 만들어 내지만  upStr는 String 입니다.

```haskell
upCase :: String -> Writer String String 
upCase s = Writer (map toUpper s, "upCase ")
```

이는 컴파일러가 다음과 같이 do 블록을 제거하기 때문 입니다.

```haskell
process s = 
	upCase s >>= \upStr -> toWords upStr
```

upCase의 모나딕 리턴 값은 String을 입력받는 람다식과 바인딩 되었습니다. 이는 아래와 같이 do 블럭에서 나오는 string 과 같은 이름입니다.

```haskell
upStr <- upCase s
```

pseudo-imperative 스타일은 toWords를 인라인할때 더 두드러 집니다. 이를 "toWords"를 로깅하는 tell로 대체할 수 있습니다.

```haskell
process s = do
	upStr <- upCase s
	tell "toWords "
	return (words upStr)

-- 여기서 do 블럭의 각 줄은 다음과 같은 네스티드 바인딩으로 제거됩니다.

proces s =
	upCase s >>= \upStr ->
		tell "toWords" >>= \() ->
			return (words upStr)
```

tell이 unit value를 만들기 때문에 다음 람다에 전달될 필요는 없습니다.  모나드 결과의 내용을 무시하는것은(이 효과는 아님 - 여기서 로그에 대한 기여도) 매우 일반적 이므로 이 경우 bind를 대체하는 특수 연산자가 있습니다.

```haskell
(>>) :: m a -> m b -> m b
m >> k = m >>= (\_ -> k)
```

실제 코드는 다음과 같이 제거됩니다.

```haskell
process s = 
	upCase s >>= \upStr ->
		tell "toWords" >>
			return (words upStr)
```

일반적으로 do 블럭은 왼쪽 화살표를 사용하여 나머지 코드블럭에서 사용할 수 있는 새 이름을 도입하거나 순전히 사이드 이펙트를 위해 실행되는 행(또는 하위 블럭)으로 구성됩니다. 줄 사이에 바인드 연산자는 암시적 입니다. 덧붙여서 하스켈에서 do 블럭의 형식을 중괄호와 세미콜론으로 바꿀 수 있습니다. 이것은 세미콜론을 오버로드하는 방식으로 모나드를 설명하는 정당성을 제공합니다.

do 표기법을 제거할때 중첩된 람다 및 바인드 연산자는 각 행의 결과에 따라 나머지 do 블록의 실행에 영향을 주는 효과가 있습니다. 이 속성은 예를들어 예외를 시뮬레이션 하기위해 복잡한 제어 구조를 도입하는데 사용할 수 있습니다.

흥미롭게도 do 표기법에 해당하는 것이 특리 C++과 같은 명령형 언어의 적용과 대응한다는 점을 발견했습니다. 나는 resumable 함수나 코루틴에 대하여 이야기 하고 있습니다. C++ [future가 모나드를 형성](https://bartoszmilewski.com/2014/02/26/c17-i-see-a-monad-in-your-future/) 한다는 것은 비밀이 아닙니다. 이는 곧 설명할 연속 모나드의 예 입니다. 연속의 문제는 합성하기가 매우 어렵다는 점 입니다. 하스켈에서 do 표기법을 이용하여 my Handler가 your handler를 호출할것 이라는 스파게티 코드를 순차코드와 매우 유사한 것으로 바꾸었습니다. Resumable 함수는 C++ 에서 동일한 변환을 가능하게 합니다. 그리고 똑같은 매커니즘이 [중첩된 loop 스파게티](https://bartoszmilewski.com/2014/04/21/getting-lazy-with-c/) 코드를 리스트 모나드의 기본 표기법인 목록 이해(comprehensions) 또는 "생성자" 로 바꿀 수 있습니다. 모나드의 통합 추상화 없이 이러한 문제는 일반적으로 언어에 대한 커스텀 extension을 제공하여 해결됩니다. 하스켈에서 이것은 모두 라이브러리를 통해 처리됩니다. 





















