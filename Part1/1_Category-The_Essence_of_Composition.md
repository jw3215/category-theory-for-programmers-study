
## 1. Category: The Essence of Composition
: 카테고리는 매우 간단한 컨셉이다. 카테고리는 object와 이들간의 arrow로 구성되어 있다. 그러나 카테고리의 본질은 합성입니다. 또는 반대로 합성의 본질이 카테고리라 할 수 있습니다.

- 카테고리의 element
	- object: 원자와 같은 primitive한 존재
	- morphism: 마찬가지로 primitive함, 모든 화살표는 시작과 끝이 있고 이는 오브젝트간의 관계를 나타낸다
오브젝트간에는 화살표가 없거나 무수히 많이 존재할 수 있다, 반대의 경우도 존재하고 오브젝트 자체로 돌아오는 화살표도 존재 할 수 있다.

- 카테고리의 속성: 합성
	- 만일 오브젝트 a, b, c간에 다음과 같은 a → b, b → c 사상이 존재한다면 a → c도 무조건 존재 하여야 한다. 이를 합성이라한다

카테고리의 element인 object와 arrow는 어떤 구조도 없습니다(추상화된 상태). 하지만 합성은 정보를 포함합니다.


### 1.1 Arrows as Functions
: 화살표는 사상(morphisms), 혹은 함수라고 할 수 있습니다. 인자로 타입 A를 받아 B 타입을 반환하는 함수 f가 있고 타입 B를 인자로 받아 타입 C를 반환하는 함수 g가 있을때 f의 결과값을 g에 입력하여 둘을 합성 할 수 있습니다. 이는 타입 A를 받아 타입 C를 반환하는 새로운 함수입니다.

수학에서 위와같은 합성은 함수 사이의 작은 원 ◦ 으로 나태낼 수 있습니다.  → 𝑔 ∘ 𝑓 (수학과 Haskell 에서는 합성 방향을 오른쪽 → 왼쪽으로 나타내고 이는 g after f로 읽습니다.)

```swift
func f(a: A) -> B 
func g(b: B) -> C

func gAfterF(a: A) -> C {
	return g(f(a))
}
```

```haskell
f :: A -> B
g :: B -> C

g.f
g◦f
```


### 1.2 Properties of Composition
: 합성엔 매우 중요한 두가지 조건이 있습니다.

1. 합성에는 결합법칙이 (associative)이 존재합니다.
	```haskell
	-- h∘(𝑔∘𝑓)=(h∘𝑔)∘𝑓 =h∘𝑔∘𝑓
	-- In (pseudo) Haskell
	f :: A -> B
	g :: B -> C
	h :: C -> D
	h . (g . f) == (h . g) . f == h . g . f
	```
	(결합법칙은 함수를 다룰때 매우 분명하지만 다른 범주에서는 명확하지 않을 수 있습니다.)

2. 모든 Object에는 identity 화살표가 존재합니다.
	: 이 화살표는 객체 자체로 반복됩니다. identity arrow는 A에서 시작해서 A에서 끝나는 화살표를 나타내고 반대방향도 가능합니다. 객체 A의 단위 화살표는 id𝐴(identity on A)로 나타냅니다.
	```haskell
	𝑓 ∘ id𝐴 = 𝑓
	-- and
	id𝐵 ∘ 𝑓 = 𝑓
	```
	함수에서 단위 화살표 구현은 입력 인자를 그대로 반환하는것으로 swift에서 다음과 같이 나타낼 수 있습니다.
	```swift
	func id<T>(x: T) -> T {
		return x
	}
	```
	하스칼에서 identity function은 스탠다드 라이브러리에 포함되어 있습니다.
	```haskell
	-- declaration and definition
	id :: a -> a
	id x = x
	```

* 요약: 카테고리는 객체와 화살표(사상)으로 구성된다, 화살표는 합성 가능하고 합성엔 결합법칙이 존재합니다. 모든 객체는 identity 화살표를 지니고 합성의 단위로 쓰인다.

### 1.3 Composition is the essence of Programming
: 기본적으로 프로그래밍은 컴퓨터가 무엇을 해야하는지를 나타냅니다. ("주소  x에 있는 메모리를 읽어서 y 레지스터에 써라") 하지만 어셈블리 프로그래밍을 할 때도 사용하는 instruction은 더 의미있는 표현 입니다. 우리는 컴퓨터가 필요할 정도로 사소하지 않은 문제를 프로그램으로 해결합니다. 이때 우리가 문제를 해결하는 방식을 생각해보면 우리는 큰 문제를 작은 문제로 나누어 생각합니다. 만일 작게 나눈 문제가 아직도 크다면 더 쪼개기를 반복합니다. 최종적으로 우리는 작은 문제를 해결하기 위해 프로그램을 작성합니다. **그리고 우리는 다시 큰 문제를 해결하기 위해서 이 조각들을 합성합니다.** 애초에 합성이 가능하지 않았다면 분해(decomposition)또한 가능하지 않았을 겁니다. (문제를 분해하고 다시 합성하는 과정은 컴퓨터에게 필요한는 작업이 아닙니다. 이는 한정적 데이터양만 처리할 수 있는 인간의 뇌의 특성에 의거합니다. )

 그러면 프로그램의 합성을 위한 적절한 사이즈는 무엇일까요? 입체 물체에 비교한다면 표면적은 우리가 합성을 위하여 알아햐는 정보이고 부피는 그것을 구현하기 위한 정보의 양이라 할 수 있습니다. 객체 지향 언어에서 표면적은 클래스의 정의나 그것의 추상화된 인터페이스라고 할 수 있습니다. 함수형 언어에서는 함수의 선언이 표면적 입니다. 카테고리 이론은 적극적으로 객체의 내부를 바라보는 것을 지양합니다. 카테고리 이론에서 객체는 추상적인 모호한 실체 입니다. **당신이 알아야할것은 객체가 어떻게 다른 객체와 관련되어 있는지, 화살표를 이용하여 어떻게 연결되어 있는지 입니다.** 만일 합성을 위하여 내부구현을 들여다 봐야한다면 프로그래밍 패러다임의 이점을 누릴 수 없는것과 마찬가지 입니다.

