## 11. Declarative Programming

이전 파트에서는 카테고리 이론과 프로그래밍은 합성에 관한것이라 이야기 하였었습니다. 프로그래밍에서 우리는 큰 문제를 우리가 다룰 수 있는 단위까지 쪼개어나가고, 작은 단위의 문제를 해결하여 바텀업 방식으로 다시 합성하여 큰 문제를 해결합니다. 단순하게 말해서 이것을 하는것에 두가지 방법이 있습니다: 컴퓨터에게 무엇을 해라라고 말하거나 혹은 어떻게 해라라고 말하거나. 전자는 선언적이고 후자는 명령적 입니다.

매우 기본적인 레벨에서 이를 볼 수 있습니다. 합성은 선언적인 방식으로 정의될 수 있습니다.

```haskell
h = g . f
```

혹은 명령적으로는 먼저 f를 호출하고 결과를 기억했다가 그것으로 다시 g를 호출한다 말할 수 있습니다.

```haskell
h x = let y = f x
			in g y
```

명령형적인 프로그램은 종종 시간에 따른 동작을 서술합니다. 특히 위에서 g는 f가 끝나기 이전에 호출될 수 없습니다. 레이지한 언어에서 적어도 다음과 같은 개념적 그림이 있습니다. 필요에 따라 아규먼트를 넘기고 실제로는 다르게 실행 될 수 있다.

사실 컴파일러가 얼마나 똑똑하냐에 따라서 선언적이거나 명령적인 코드가 실행되는 타이밍은 약간다르거나 차이가 없을수도 있습니다. 하지만 두가지 방법론의 차이는 우리가 문제를 해결하거나, 유지하고 결과를 테스트하는데 극단적으로 증가합니다.

메인 질문은 이것입니다: 문제를 해결해야하는 상황에서 항상 선언적인 방법과 명령적인 방법 사이에서 선택하여야 합니까? 그리고 선언적인 방법이 있다면 그것을 컴퓨터 코드로 나타낼 수 있습니까? 이 질문의 답은 분명하지는 않습니다. 하지만 우리가 선언적으로 풀어낼 수 있는 방법을 찾을 수 있다면 아마도 우주에 대한 우리의 이해에 큰 혁명을 일으킬 것 입니다.

물리학에도 비슷한 이중성(duality)이 있습니다. 하나는 디테일하게 기본 원리에 집중하는 것이고 다른 하나는 어떻게 우리의 생각이 작동하는지 입니다. Richard Feynman은 양자 전기 역학에 대한 자신의 연구에서 이 이중성에 영감을 받았다 언급했습니다.

대부분의 물리법칙을 나타내는 두가지 방식이 있습니다. 하나는 지역적이거나 미미한 고려사항을 이용하는 것입니다. 전체 시스템의 상태를 작은 부분에서 시작하고 다음시간에 어떻게 변할지 예측합니다. 이는 일반적으로 일정 기간동안 통합되거나 합산되어야하는 미분 방정식을 이용하여 표현됩니다.

이 접근 방식이 명령적 프로그래밍과 어떻게 유사한지 주목하세요. 각 단계가 이전 단계의 결과와 관련이 있는 작은 단계를을 지나 최종 결과를 얻습니다. 사실상 물리 시스템의 컴퓨터 시뮬레이션은 미분방정식을 미분방정식으로 바꾸고 그것들을 합하는 방식으로 구현됩니다. 비행선 게임에서 함선이 움직이는 원리와 동일합니다. 시간에따라 함선의 위치는 조금씩 변하고 변화향은 속도와 시간차이를 이용하여 계산됩니다. 속도는 질량으로 나눠진 힘으로 주어진 가속도에 비례해서 차례대로 조금씩 변경됩니다.(이후 생략)

다른 방식은 전역적(global)입니다. 시스템의 초기상태와 최종 상태를 보고 특정 기능을 최소화 하여 둘을 연결하는 궤도를 계산합니다. 가장 단순한 예는 페르마의 최소시간 원칙 입니다. 이에 따르면 광선은 비행 시간을 최소화하는 경로로 움직입니 특히 반소나 굴절 물체가 없는경우 지점 A에서 B까지 경로 중 직선인 경우 최단경로입니다. 하지만 물이나 렌즈 에서와 같이 광선은 밀도가 높은 물질을 통과할 느리게 전파됩니다. 따라서 시작점이 공기이고 종료점이 물속일때 광선의 경로는 공기에서 더 오래 이동할수록 최단경로가 됩니다. 그렇기떄문에 광선이 공기에서 물을 지날때 굴절이 일어납니다.

모든 고전 역학은 최소행동 원칙에서 파생될 수 있습니다. 운동에너지와 잠재에너지로 인한 운동궤적 예시 생략

페르마의 가장 큰 공헌은 최소 행동 원리가 양자 역학으로 일반화 될 수 있다는 사실을 깨닫게 해줬다는 점 입니다. 여기서 문제는 초기 상태와 최종 상태로 공식화 됩니다. 이러한 상태간의 Feynman 경로 적분은 전환 확률을 계산하는데 사용됩니다.

요점은 우리가 물리 법칙을 설명할 수 있는 방식에 이중성이 있다는 점 입니다. 부분적으로 순차적으로 일어나는 일에 대한 이미지도 있고 초기상태와 최종상태를 정함에 따라 따라오는 전역적인 이미지도 있습니다.

전역적인 접근은 프로그래밍에도 적용할 수 있습니다. 예를들어 광선 트레이싱을 구현하는 경우, 먼저 눈과 광원의 위치를 선언하고 어떻게 광선의 경로가 결정될지 결정하면됩니다. 각 광선의 비행시간을 이용하여 국소적인 시각에서 연속적인 계산을 이용하지 않아도 Snell의 법칙과 반사 기하학을 사용하면 됩니다.

지역적인(local) 접근과 전역적인(global) 접근법의 제일 큰 차이는 이들이 공간, 특히 시간을 다루는 방식입니다. 지역적인 접근은 지금, 여기에 대한 즉각적인 충족을 요구하고, 전역적인 접근법은 이미 미래가 정해져있고 영원한 우주의 속성 일부만 분석하는 장기적이고 고정적인 방식을 취합니다.

사용자 상요 작용에 대하여 펑셔널 리엑티브 프로그래밍(FRP)의 접근 방식보다 더 잘 설명된곳은 없습니다. 가능한 모든 유저 인터엑션에 대한 모든 핸들러를 구현하는것 대신에 FRP는 외부 이벤트를 무한한 리스트로 간주하여 공유되는 수정가능한 상태에 접근하여 연속적인 변화를 적용합니다. 개념적으로 미래에 예정된 모든 액션들은 프로그램에 입력되는 데이터로 간주할 수 있습니다. 프로그래머의 관점에서 그것은 숫자이거나, 원주율이거나, 가짜의 랜덤넘버나 혹은 마우스 포지션 변경점 리스트이든 아무 차이도 없습니다. 각각의 경우에 n번쨰 항목을 얻기위해서는 먼저 첫번째에서 n-1번째까지의 항목을 거쳐야합니다. 시간적 이벤트 적용될때 우리는 이 속성을 인과관계라 부릅니다.

이것들이 카테고리 이론과 무슨 연관이 있을까요? 카테고리 이론은 전역적인 접근법을 추구하고 그러므로 선언적 프로그래밍을 지원합니다. 우선 미적분과 다르게 거리, 주변, 또는 시간에 대한 개념이 내장되어있지 않습니다. 카테고리에 있는전부는 추상화된 대상과 그들간의 추상화된 연결입니다. A에서 B까지 여러단계의 스탭으로 도달할 수 있다면 한번에 도약하는 방법이 있음을 말합니다. 또한 카테고리이론의 중요한 툴은 universal construction 이고 이는 전역적 접근(~~포괄적이 더 맞는 표현이려나..~~)의 전형입니다. 카테고리적 곱에서 이를 보았습니다. 이는 속성을 지정하며 수행되었고 매우 선언적인 접근법 이였습니다. 두개의 프로젝션을 지닌 대상이 있고 이는 이런 종류의 최상의 객체입니다. 이것은 다른 객체의 프로젝션을 인수분해 하는 특정 속성을 최적화 합니다.

이를 페르마의 최단시간 원리나 최소작용의 원리와 비교해보세요.

반대로 훨씬 더 명력적인 카르테시안 곱의 전통적인 정의와 대조해보세요. 한 집합에서 한 원소를 선택하고 다른 집합에서 다른 원소를 선택하여 곱의 요소를 만드는 방법을 설명합니다. 이것은 쌍을 만드는 방법입니다. 그리고 이를 분해하는 방법도 있습니다.

범주형 프로그래밍을 만드려는 시도가 있었지만(see, e.g., Tatsuya Hagino’s thesis1) 하스켈을 포함하여 대부분의 함수형 프로그래밍에서 product, coproduct, function 타입들은 universal construction으로 정하는것 대신에 기본으로 내장되어 있습니다.

직접 사용하든 안하든 카테고리적 정의는 기존 프로그래밍의 구조를 정당화하고 새로운 구조를 생성합니다. 가장 중요한 점은 카테고리 이론이 선언적 수준에서 컴퓨터 프로그램에 대한 추론을 위한 메타 언어를 제공한다는 점입니다. 또한 코드를 먼저 작성하기 이전에 문제의 스펙에 대한 추론을 먼저 내리는것을 장려합니다.







