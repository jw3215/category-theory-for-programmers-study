## 16. Yoneda Embedding

이전에 카테고리 C에서 a를 고정시키고 C(a, -)로의 매핑은 C에서 Set으로 향하는 (공변) 펑터 임을 보았습니다. 

```haskell
x -> C(a, x)
```

(공역은 hom-set C(a, x)이고 이것은 집합이기 때문에 Set 입니다.). 이를 홈펑터라 불렀었고 이것이 사상에대해서도 동작함을 정의했었습니다.

이번에는 이 매핑에서 a를 바꿔봅시다. 그러면 이제 모든 a에 대하여 hom-functor C(a, -)를 할당하는 새로운 매핑을 얻습니다.

```haskell
a -> C(a, -)
```

이는 카테고리 C의 대상에서 펑터로 매핑합니다. 그리고 펑터는 펑터 카테고리에 존재합니다. C에서 Set으로 향하는 펑터를 [C, Set]으로 나타냅시다. 또한 홈펑터는 표현가능한 펑터의 원형이라는 점을 기억합시다.

두 카테고리간 대상을 매핑할때마다 이것이 펑터인지 되묻는것은 자연스럽습니다. 다시말해서 그러면 사상도 리프팅 할 수 있는지 확인해야 합니다. C에 있는 사상은 단지 C(a, b)의 원소입니다. 하지만 [C, Set] 펑터 카테고리에서의 사상은 자연변환 입니다. 그렇기 때문에 우리는 사상에서 자연변환으로의 매핑을 찾아야 합니다.

f :: a -> b에 해당하는 자연변환을 찾을 수 있는지 한번 알아봅시다. 우선 a, b가 무엇으로 매핑되는지 봅시다. 이들을 각자 C(a, -), C(b, -)로 매핑됩니다. 그리고 이제 이들간의 자연변환이 필요합니다.

```haskell
-- 오네다 레마를 이용
[C, Set](C(a, -), F) ≅ F a
-- F를 C(b, -)호 치환
[C, Set](C(a, -), C(b, -)) ≅ C(b, a)
```

![](https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding.jpg?w=372&h=180)

약간 뒤집히기는 했지만 이는 우리가 찾고있는 두 홈펑터간의 자연변환에 매칭됩니다: 자연변환과 사상 사이의 매핑이지만 방향이 반대입니다. 하지만 괜찮습니다. 이는 반변을 의미합니다.

![](https://bartoszmilewski.files.wordpress.com/2015/07/yoneda-embedding-2.jpg?w=768&h=280)

사실 우리가 찾는것 이상의 결과를 얻었습니다. C 에서 [C, Set]으로의 매핑은 반변펑터 이상입니다. 이는 충만히 충실한 펑터(fully faithful functor) 입니다. 충만함과 충실함은 펑터의 속성이고 홈셋을 어떻게 매핑하는지를 묘사합니다.

홈셋에 injective한 충실한 펑터는 구분되는 사상으로 매핑됨을 뜻합니다. 즉 공역이 겹치는 부분이 없음을 뜻합니다.

홈셋에 subjective한 충만한 펑터는 한 홈셋에서 다른 홈셋으로 매핑할떄 후자를 모두 커버함을 뜻함니다.

충만하고 충실한 펑터 F는 홈셋에 전단사(bijection) 합니다. - 두 집합의 모든 원소를 일대일로 매핑 시킵니다. 소스 카테고리 C의 모든 원소 쌍 a, b에 대하여 C(a, b), D(Fa, Fb)간의 bijection이 존재합니다. (여기서 카테고리 D는 F의 타겟 카테고리 이고 우리의 경우에는 [C, Set]를 의미합니다.) F가 대상에 대하여 bijection하지 않다는 점에 주목하세요. D에는 F의 상이 아닌 대상이 존재할 수 있습니다. 그리고 이것들에대한 홈셋은 거론할 수 없습니다.

### 16.1 The Embedding

앞서 묘사한 (반변) 펑터는 C의 대상을 [C, Set]으로 매핑하고 이는 Yoneda embedding을 정의합니다.

```haskell
a -> C(a, -)
```

이는 카테고리 C(엄밀히 말해서 이는 반변이기 때문에 Cop 카테고리 입니다.)를 [C, Set]로 임베딩 시킵니다. 이는 C에서 펑터로 대상을 매핑하는것은 물론 이들간의 모든 연결을 충실히 유지함을 의미합니다.

이는 매우 유용합니다. 특히 수학자들은 공역이 Set인 펑터의 카테고리에 대하여 많은것을 알기 때문입니다. 우리는 임의의 카테고리 C를 펑터 카테고리로 임베딩 시킴으로서 많은 통찰을 얻을 수 있습니다.

역시 요네다 임베딩에는 쌍대개념이 있고 이를 co-Yoneda embedding이라 부릅니다. (나머지 생략)

```haskell
[C, Set](C(-, a), C(-, b))  ≅ C(a, b)
```



### 16.2 Applicatiom to Haskell

하스켈에서 요네다 임베딩은 리더 펑터간의 자연변형과 다른 한편으로는 함수(반대방향으로 진행되는)간의 동형 사상으로 나타낼 수 있습니다. 

```haskell
forall x. (a -> x) -> (b -> x) ≅ b -> a
```

여기서 좌변은 a -> x 까지의 함수와 타입 b가 주어지면 x 값을 생성할 수 있다는 다형성 함수 입니다.(b -> x를 감싸는 괄호를 삭제하지 않은 언커링 버전) 모든 x에 대하여 수행될 수 있는 유일한 방법은 b를 a로 어떻게 바꾸는것 인지 입니다.

이와같은 컨버터 btoa가 주어졌을때 좌변을 다음과 같이 정의할 수 있습니다.

```haskell
fromY :: (a -> x) -> b -> x
fromY f b -> f (btoa b)
```

반대로 fromY에 id를 호출하여 주어진 fromY를 바탕으로 컨버터를 복구할 수 있습니다.

```haskell
fromY id :: b -> a
```

이는 fromY와 btoa 타입 함수 사이에서 bijection 를 형성합니다.

이 동형은 b -> a로의 함수를 cps로 인코딩 된것으로 볼 수 있습니다. a -> x는 continuation(handler)입니다. 결과는 b -> x로 가는 함수입니다. 이는 b타입 값과 함께 호출될때 인코딩되는 함수호 미리 합성된 continutation을 실행합니다.

요네다 임베딩은 하스켈에서 특정 데이터 스트럭쳐를 설명하는 대안으로 쓰입니다. 이는 특히 Control.Lens 라이브러리에 있는 [very useful representation](https://bartoszmilewski.com/2015/07/13/from-lenses-to-yoneda-embedding/) 의 lenses 를 제공합니다.



### 16.3 Preorder Example - 생략

### 16.4 Naturality

요네다 레마는 자연변환의 집합과 Set의 대상간의 동형사상을 성립하였습니다. 자연변환은 펑터 카테고리 [C, Set]의 사상입니다. 임의의 두 펑터간의 자연변환의 집합은 이 카테고리에서의 홈셋입니다. 요네다 레마는 동형사상입니다.

```haskell
[C, Set](C(a, -), F) ≅ Fa
```

이 동형은 F와 a에 대해서 모두 내추럴 하다는 것이 들어났습니다. 다른말로해서 곱의 카테고리 [C, Set] x C에서 (F, a) 페어는 내추럴 하다는 점입니다. F를 펑터카테고리의 대상으로 여기는것에 주목하세요.

이것이 무엇을 의미하는지 봅시다. 자연 동형은 두 펑터간의 자연변환에 역이 존재하는 경우 입니다. 실제로 우리의 동형에서 우변은 펑터입니다.([C, Set] X C에서 Set으로 향하는) 쌍 (F, a)에 대한 동작은 집합입니다 - 대상 a에 F 펑터를 적용한 결과입니다. 이는 evaluation 펑터 라고 부릅니다.

좌변역시 (F, a) 쌍을 취해 [C, Set] (C(a, -), F) 자연변환 집합으로 매핑하는 펑터입니다.

이것이 진짜 펑터임을 보이기 위하여 사상에 대해서도 동작함을 보여야합니다. 쌍 (F, a) (G, b) 사이의 사상은 무엇일까요? 이는 다음과 같은 사상의 쌍 입니다. (Φ, 𝑓 ) 첫번쨰는 두 펑터간의 자연변환을 의미하고 두번때는 카테고리 C의 일반 사상입니다.

evaluation functor는 (Φ, 𝑓 ) 쌍을 취하여 Fa, Fb두 집합간의 함수로 매핑합니다.





 